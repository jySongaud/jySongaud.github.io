<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>404</title>
      <link href="/2020/07/18/404/"/>
      <url>/2020/07/18/404/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener" title="LeetCode 912. 排序数组">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre><code class="cpp">class Solution {public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {        return quickSort(nums);    }    // 冒泡排序（超时）    vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int i = 0; i &lt; n; ++i) {            for (int j = n-2; j &gt;= i; --j) {                if (nums[j] &gt; nums[j+1]) {                    swap(nums[j], nums[j+1]);                }            }        }        return nums;    }    // 选择排序（超时）    vector&lt;int&gt; selectSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int i = 0; i &lt; n; ++i) {            int idx = i;            for (int j = i; j &lt; n; ++j) {                if (nums[j] &lt; nums[idx]) {                    idx = j;                }            }            swap(nums[i], nums[idx]);        }        return nums;    }    // 插入排序（超时）    vector&lt;int&gt; insertSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int i = 0; i &lt; n; ++i) {            for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) {                swap(nums[j], nums[j-1]);            }        }        return nums;    }    // 快速排序（24 ms）    void qSort(vector&lt;int&gt;&amp; nums, int l, int r) {        if (l &gt;= r) return;        int m = l;        for (int i = l; i &lt; r; ++i) {            if (nums[i] &lt; nums[r]) {                swap(nums[m++], nums[i]);            }        }        swap(nums[m], nums[r]);        qSort(nums, l, m-1);        qSort(nums, m+1, r);    }    vector&lt;int&gt; quickSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        qSort(nums, 0, n-1);        return nums;    }    // 归并排序（192 ms）    vector&lt;int&gt; mSort(vector&lt;int&gt;&amp; nums, int l, int r) {        if (l &gt;= r) return {nums[l]};        int m = l+(r-l)/2;        vector&lt;int&gt; lnums = mSort(nums, l, m);        vector&lt;int&gt; rnums = mSort(nums, m+1, r);        vector&lt;int&gt; res;        int i = 0, j = 0;        while (i &lt;= m-l &amp;&amp; j &lt;= r-m-1) {            if (lnums[i] &lt; rnums[j]) {                res.push_back(lnums[i++]);            } else {                res.push_back(rnums[j++]);            }        }        while (i &lt;= m-l) {            res.push_back(lnums[i++]);        }        while (j &lt;= r-m-1) {            res.push_back(rnums[j++]);        }        return res;    }    vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        nums = mSort(nums, 0, n-1);        return nums;    }    // 归并排序 + 非递归（80 ms）    vector&lt;int&gt; mergeSortNR(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int len = 1; len &lt; n; len &lt;&lt;= 1) {            for (int l = 0; l &lt; n-len; l += 2*len) {                int m = l+len-1;                int r = min(n-1, l+2*len-1);                vector&lt;int&gt; res;                int i = l, j = m+1;                while (i &lt;= m &amp;&amp; j &lt;= r) {                    if (nums[i] &lt; nums[j]) {                        res.push_back(nums[i++]);                    } else {                        res.push_back(nums[j++]);                    }                }                while (i &lt;= m) {                    res.push_back(nums[i++]);                }                while (j &lt;= r) {                    res.push_back(nums[j++]);                }                for (int i = l; i &lt;= r; ++i) {                    nums[i] = res[i-l];                }            }        }        return nums;    }    // 希尔排序（40 ms）    vector&lt;int&gt; shellSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int gap = n/2; gap &gt; 0; gap /= 2) {            for (int i = gap; i &lt; n; ++i) {                for (int j = i; j-gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap) {                    swap(nums[j-gap], nums[j]);                }            }        }        return nums;    }    // 计数排序（32 ms）    vector&lt;int&gt; countSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        if (!n) return {};        int minv = *min_element(nums.begin(), nums.end());        int maxv = *max_element(nums.begin(), nums.end());        int m = maxv-minv+1;        vector&lt;int&gt; count(m, 0);        for (int i = 0; i &lt; n; ++i) {            count[nums[i]-minv]++;        }        vector&lt;int&gt; res;        for (int i = 0; i &lt; m; ++i) {            for (int j = 0; j &lt; count[i]; ++j) {                res.push_back(i+minv);            }        }        return res;    }    // 基数排序（不适用于负数）    vector&lt;int&gt; radixSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int maxv = *max_element(nums.begin(), nums.end());        int maxd = 0;        while (maxv &gt; 0) {            maxv /= 10;            maxd++;        }        vector&lt;int&gt; count(10, 0), rank(n, 0);        int base = 1;        while (maxd &gt; 0) {            count.assign(10, 0);            for (int i = 0; i &lt; n; ++i) {                count[(nums[i]/base)%10]++;            }            for (int i = 1; i &lt; 10; ++i) {                count[i] += count[i-1];            }            for (int i = n-1; i &gt;= 0; --i) {                rank[--count[(nums[i]/base)%10]] = nums[i];            }            for (int i = 0; i &lt; n; ++i) {                nums[i] = rank[i];            }            maxd--;            base *= 10;        }        return nums;    }    // 桶排序 (20 ms)    vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int maxv = *max_element(nums.begin(), nums.end());        int minv = *min_element(nums.begin(), nums.end());        int bs = 1000;        int m = (maxv-minv)/bs+1;        vector&lt;vector&lt;int&gt; &gt; bucket(m);        for (int i = 0; i &lt; n; ++i) {            bucket[(nums[i]-minv)/bs].push_back(nums[i]);        }        int idx = 0;        for (int i = 0; i &lt; m; ++i) {            int sz = bucket[i].size();            bucket[i] = quickSort(bucket[i]);            for (int j = 0; j &lt; sz; ++j) {                nums[idx++] = bucket[i][j];            }        }        return nums;    }    // 堆排序（32 ms）    void adjust(vector&lt;int&gt;&amp; nums, int p, int s) {        while (2*p+1 &lt; s) {            int c1 = 2*p+1;            int c2 = 2*p+2;            int c = (c2&lt;s &amp;&amp; nums[c2]&gt;nums[c1]) ? c2 : c1;            if (nums[c] &gt; nums[p]) swap(nums[c], nums[p]);            else break;            p = c;        }    }    vector&lt;int&gt; heapSort(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int i = n/2-1; i &gt;= 0; --i) {            adjust(nums, i, n);        }        for (int i = n-1; i &gt; 0; --i) {            swap(nums[0], nums[i]);            adjust(nums, 0, i);        }        return nums;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
